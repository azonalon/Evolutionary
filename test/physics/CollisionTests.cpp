#include "physics/ElasticModel.hpp"
#include "physics/ElasticModelCollision.hpp"
#include "util/Assertions.hpp"

void twoTriangleCollision() {
    // tests an elastic model where two triangles collide with constant
    // relative speed and no external forces
    double nuV = 0.33;
    double kV =  1.0;
    const std::vector<double> vertices =  {
        0, 0, 0, 1, 1, 0,
        2, 2, 2, 3, 3, 2,
    };
    const std::vector<double> k(2, kV);
    const std::vector<double> nu(2, nuV);
    const std::vector<double> M(vertices.size(), 1.0);
    const std::vector<std::array<unsigned int,3>>indices =  {{0,1,2}, {3,4,5}};
    ElasticModel::ElasticModelType modelType = ElasticModel::ElasticModelType::INVERTIBLE_NEOHOOKEAN;
    ElasticModel em(vertices, indices, k, nu, M, modelType, (double)0.3);
    for(int i=0; i<6; i++) {
        em.x1(6+i) += 0.01;
    }
    em.kDamp = 0.1;
    em.dt = 0.01;
    for(double t=0; t<2; t+=em.dt) {
        em.implicitEulerStep();
        std::cout << em.x2.transpose() << std::endl;
    }
}


int main() {
    double eps = 1e-3;
    assert(pointInTriangle(0.2, 0.2, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0));
    assert(!pointInTriangle(-0.2, -0.2, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0));
    assert(pointInTriangle(304, 328, 254, 439, 338, 422, 328, 64));
    assert(pointInTriangle(304, 328, 338, 422, 254, 439, 328, 64));
    assert(!pointInTriangle(146, 399, 469, 348, 116, 329, 247, 459));

    assert(!pointInTriangle(0.46, 0.46, 0.46, 348, 116, 329, 247, 459));

    assertEqualsTest(
        squarePointLineSegmentDistance(
            3.66762, 2.3719, 7.1437, -8.07742, -6.1863, -3.29061
        ),
        74.9895,
        eps);

    assertEqualsTest(
        squarePointLineSegmentDistance(
            3.66762, 2.3719, 7.1437, -8.07742, -6.1863, -3.29061
        ),
        74.9895,
        eps);

    Eigen::ArrayXd f(6);
    Eigen::ArrayXd x(6);
    f = 0;
    Eigen::ArrayXd fCorrect(6);
    fCorrect << 28.6791446572775766886650102458554971569801253354024,
                1.8050899072238513504521684056544115454601232666713,
                -19.3699038606470229958711277163287945787650574108902,
                -1.2191583249982923263710003700984536688989072369350,
                -9.30924079663055369279388252952670257821506792451220,
                -0.5859315822255590240811680355559578765612160297364;

    x << 4.3018108378542194714100332930684089660644531250000,
        -2.2019152462675677384140726644545793533325195312500,
        1.02830595179018047247154754586517810821533203125000,
        0.53786462872957230274550965987145900726318359375000,
        1.59725485938368905181050649844110012054443359375000,
        -8.5015565979776681615476263687014579772949218750000;

    addSelfCollisionPenaltyForce({0, 2, 4}, x, f);
    // assertArrayEquals(f, -fCorrect, 1e-15);

    Eigen::Matrix<double, 6, 6> hCorrect;
    hCorrect <<
        18.49634466568558257187598004001057782620534428960,
        1.164175761709489745288658677968059668007907924760,
        -12.293534444338309556116317360209577253531584551956,
        -0.773765578254535629101685312755182404417175472302,
        -6.202810221347273015759662679801000572673759737644,
        -0.390410183454954116186973365212877263590732452458,
        1.164175761709489745288658677968059668007907924760,
        0.0732742186982616504179562017425194134353141105132,
        -3.946440458427636286128221452020869819475149387178,
        -0.2483923396634460322120332671887839595773004751657,
        2.782264696718146540839562774052810151467241462418,
        0.1751181209651843817940770654462645461419863646525,
        -12.293534444338309556116317360209577253531584551956,
        -3.946440458427636286128221452020869819475149387178,
        7.088874059741325808793998041711519241300340255204,
        2.589005471263980807245438278959937045371001327412,
        5.204660384596983747322319318498058012231244296752,
        1.357434987163655478882783173060932774104148059766,
        -0.773765578254535629101685312755182404417175472302,
        -0.2483923396634460322120332671887839595773004751657,
        2.589005471263980807245438278959937045371001327412,
        0.297825501446204740492729133583845102802012949694,
        -1.815239893009445178143752966204754640953825855111,
        -0.049433161782758708280695866395061143224712474528,
        -6.202810221347273015759662679801000572673759737644,
        2.782264696718146540839562774052810151467241462418,
        5.204660384596983747322319318498058012231244296752,
        -1.815239893009445178143752966204754640953825855111,
        0.998149836750289268437343361302942560442515440892,
        -0.967024803708701362695809807848055510513415607308,
        -0.390410183454954116186973365212877263590732452458,
        0.1751181209651843817940770654462645461419863646525,
        1.357434987163655478882783173060932774104148059766,
        -0.049433161782758708280695866395061143224712474528,
        -0.967024803708701362695809807848055510513415607308,
        -0.125684959182425673513381199051203402917273890124;


    Eigen::Matrix<double, 6, 6> hTest;
    Eigen::Array<double,  6,1> dx(6);

    // MatrixXd m(6,6);
    for(int i=0; i<6; i++) {
        dx = 0;
        f = 0;
        dx(i) = 1.0;
        addSelfCollisionPenaltyForceDifferential({0, 2, 4}, x, dx, f);
        for(int j=0; j<6;j++) {
            hTest(i, j) = f(j);
        }
    }
    // assertArrayEquals(hTest, hCorrect, 1e-15);
    twoTriangleCollision();
}
